# NanoGridBot-rust MVP (Phase 3) 实现计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 实现最小可运行的智能体系统：Telegram 接收消息 → Docker 容器运行 Claude Code → 回复用户

**Architecture:** Rust 宿主端负责编排（Orchestrator + Telegram Channel + CLI serve），Docker 容器内运行从 nanoclaw 适配的 Node.js agent-runner（Claude Agent SDK + MCP tools）。通过 stdin/stdout + 文件 IPC 通信。

**Tech Stack:** Rust (tokio, teloxide, clap), Node.js (Claude Agent SDK, MCP SDK), Docker

**Branch:** `build-by-rust`

**前置条件：**
- Phase 1 + Phase 2 已完成（162 tests passing）
- nanoclaw 源码在 `./github.com/nanoclaw/`

---

## 概览

共 8 个 Task，分为 3 个阶段：

| 阶段 | Task | 内容 | 优先级 |
|------|------|------|--------|
| A. 容器层 | Task 1 | agent-runner 适配（从 nanoclaw） | P0 |
| A. 容器层 | Task 2 | Dockerfile + build.sh | P0 |
| B. Rust 宿主增强 | Task 3 | router.rs 消息格式化（Gap 6） | P0 |
| B. Rust 宿主增强 | Task 4 | Session ID 持久化（Gap 5） | P0 |
| B. Rust 宿主增强 | Task 5 | 容器启动准备（Gap 4） | P0 |
| C. 新模块 | Task 6 | Telegram Channel 适配器 | P0 |
| C. 新模块 | Task 7 | CLI serve 子命令 | P0 |
| C. 端到端 | Task 8 | 集成测试 + 端到端验证 | P0 |

P1 增强（流式输出、idle timeout、消息管道）在 MVP 跑通后单独迭代。

---

## Task 1: agent-runner 适配

**目标：** 从 nanoclaw 复制并适配 agent-runner，改名 nanoclaw → ngb

**Files:**
- Create: `container/agent-runner/package.json`
- Create: `container/agent-runner/tsconfig.json`
- Create: `container/agent-runner/src/index.ts`（从 nanoclaw 适配）
- Create: `container/agent-runner/src/ipc-mcp-stdio.ts`（从 nanoclaw 适配）

**Step 1: 创建 agent-runner 项目结构**

```bash
mkdir -p container/agent-runner/src
```

**Step 2: 创建 package.json**

```json
{
  "name": "ngb-agent-runner",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "@anthropic-ai/claude-agent-sdk": "^0.1.0",
    "@modelcontextprotocol/sdk": "^1.0.0",
    "zod": "^3.23.0",
    "cron-parser": "^5.0.0"
  },
  "devDependencies": {
    "typescript": "^5.5.0",
    "@types/node": "^22.0.0"
  }
}
```

**Step 3: 创建 tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}
```

**Step 4: 适配 index.ts**

从 `./github.com/nanoclaw/container/agent-runner/src/index.ts` 复制，做以下替换：
- `NANOCLAW_OUTPUT_START` → `NGB_OUTPUT_START`
- `NANOCLAW_OUTPUT_END` → `NGB_OUTPUT_END`
- `nanoclaw` → `ngb`（MCP server 引用）
- `NANOCLAW_CHAT_JID` → `NGB_CHAT_JID`
- `NANOCLAW_GROUP_FOLDER` → `NGB_GROUP_FOLDER`
- `NANOCLAW_IS_MAIN` → `NGB_IS_MAIN`
- `[agent-runner]` 日志前缀保留

**Step 5: 适配 ipc-mcp-stdio.ts**

从 `./github.com/nanoclaw/container/agent-runner/src/ipc-mcp-stdio.ts` 复制，做以下替换：
- MCP server name: `nanoclaw` → `ngb`
- 环境变量: `NANOCLAW_*` → `NGB_*`
- 工具名保持不变（send_message, schedule_task 等）

**Step 6: 同步 Rust 端 marker 常量**

修改 `crates/ngb-core/src/container_runner.rs`:
```rust
pub const OUTPUT_START_MARKER: &str = "---NGB_OUTPUT_START---";
pub const OUTPUT_END_MARKER: &str = "---NGB_OUTPUT_END---";
```

**Step 7: 运行测试确认 marker 变更不破坏现有测试**

```bash
cargo test -p ngb-core -- container_runner
```

**Step 8: Commit**

```bash
git add container/ crates/ngb-core/src/container_runner.rs
git commit -m "feat: add agent-runner adapted from nanoclaw"
```

---

## Task 2: Dockerfile + build.sh

**目标：** 创建 Docker 镜像构建文件

**Files:**
- Create: `container/Dockerfile`
- Create: `container/build.sh`
- Create: `container/skills/` (空目录，预留)

**Step 1: 创建 Dockerfile**

```dockerfile
# NanoGridBot Agent Container
FROM node:22-slim

# System dependencies for Chromium (browser automation)
RUN apt-get update && apt-get install -y \
    chromium fonts-liberation fonts-noto-color-emoji \
    libgbm1 libnss3 libatk-bridge2.0-0 libgtk-3-0 \
    curl git jq \
    && rm -rf /var/lib/apt/lists/*

ENV AGENT_BROWSER_EXECUTABLE_PATH=/usr/bin/chromium
ENV PLAYWRIGHT_CHROMIUM_EXECUTABLE_PATH=/usr/bin/chromium

# Install claude-code globally
RUN npm install -g @anthropic-ai/claude-code

WORKDIR /app
COPY agent-runner/package*.json ./
RUN npm install
COPY agent-runner/ ./
RUN npm run build

# Create workspace directories
RUN mkdir -p /workspace/group /workspace/global /workspace/extra \
    /workspace/ipc/messages /workspace/ipc/tasks /workspace/ipc/input

# Entrypoint: source env, recompile TS, read stdin, run agent
RUN printf '#!/bin/bash\nset -e\n[ -f /workspace/env-dir/env ] && export $(cat /workspace/env-dir/env | xargs)\ncd /app && npx tsc --outDir /tmp/dist 2>&1 >&2\nln -s /app/node_modules /tmp/dist/node_modules\nchmod -R a-w /tmp/dist\ncat > /tmp/input.json\nnode /tmp/dist/index.js < /tmp/input.json\n' > /app/entrypoint.sh && chmod +x /app/entrypoint.sh

RUN chown -R node:node /workspace
USER node
WORKDIR /workspace/group
ENTRYPOINT ["/app/entrypoint.sh"]
```

**Step 2: 创建 build.sh**

```bash
#!/bin/bash
set -e
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
docker build -t nanogridbot-agent:latest "$SCRIPT_DIR"
echo "Built nanogridbot-agent:latest"
```

**Step 3: 创建 skills 目录**

```bash
mkdir -p container/skills
touch container/skills/.gitkeep
```

**Step 4: Commit**

```bash
chmod +x container/build.sh
git add container/Dockerfile container/build.sh container/skills/
git commit -m "feat: add Dockerfile and build script for agent container"
```

---

## Task 3: router.rs 消息格式化 (Gap 6)

**目标：** 添加 `format_messages()` 函数，将待处理消息格式化为带时间戳和发送者的文本

**Files:**
- Modify: `crates/ngb-core/src/router.rs`
- Test: 在同文件 `#[cfg(test)]` 模块中

**Step 1: 写失败测试**

```rust
#[test]
fn format_messages_basic() {
    let messages = vec![
        Message {
            chat_jid: "tg:123".to_string(),
            sender: "Alice".to_string(),
            content: "Hello everyone".to_string(),
            timestamp: Utc.with_ymd_and_hms(2026, 1, 31, 14, 32, 0).unwrap(),
            role: MessageRole::User,
        },
        Message {
            chat_jid: "tg:123".to_string(),
            sender: "Bob".to_string(),
            content: "@Bot help me".to_string(),
            timestamp: Utc.with_ymd_and_hms(2026, 1, 31, 14, 35, 0).unwrap(),
            role: MessageRole::User,
        },
    ];
    let result = format_messages(&messages);
    assert!(result.contains("[Jan 31 2:32 PM] Alice: Hello everyone"));
    assert!(result.contains("[Jan 31 2:35 PM] Bob: @Bot help me"));
}
```

**Step 2: 运行测试确认失败**

```bash
cargo test -p ngb-core -- router::tests::format_messages_basic
```

**Step 3: 实现 format_messages**

```rust
/// Format messages for agent consumption with timestamps and sender names.
pub fn format_messages(messages: &[Message]) -> String {
    messages
        .iter()
        .map(|m| {
            let ts = m.timestamp.format("[%b %d %-I:%M %p]");
            format!("{} {}: {}", ts, m.sender, m.content)
        })
        .collect::<Vec<_>>()
        .join("\n")
}
```

**Step 4: 运行测试确认通过**

```bash
cargo test -p ngb-core -- router::tests::format_messages
```

**Step 5: Commit**

```bash
git add crates/ngb-core/src/router.rs
git commit -m "feat: add message formatting for agent context (Gap 6)"
```

---

## Task 4: Session ID 持久化 (Gap 5)

**目标：** 在 DB 中存储 per-group session ID，orchestrator 传递给容器并保存返回的 newSessionId

**Files:**
- Modify: `crates/ngb-db/src/lib.rs`（添加 SessionRepository）
- Create: `crates/ngb-db/src/sessions.rs`
- Modify: `crates/ngb-db/src/connection.rs`（添加 sessions 表）
- Modify: `crates/ngb-core/src/orchestrator.rs`（集成 session 管理）

**Step 1: 添加 sessions 表到 DB 初始化**

在 `connection.rs` 的 `initialize()` 中添加：
```sql
CREATE TABLE IF NOT EXISTS sessions (
    group_folder TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Step 2: 创建 SessionRepository**

```rust
// crates/ngb-db/src/sessions.rs
pub struct SessionRepository<'a> { db: &'a Database }

impl<'a> SessionRepository<'a> {
    pub fn new(db: &'a Database) -> Self { Self { db } }

    pub async fn get_session(&self, group_folder: &str) -> Result<Option<String>> { ... }
    pub async fn set_session(&self, group_folder: &str, session_id: &str) -> Result<()> { ... }
    pub async fn get_all_sessions(&self) -> Result<HashMap<String, String>> { ... }
}
```

**Step 3: 写测试**

```rust
#[tokio::test]
async fn session_roundtrip() {
    let db = Database::in_memory().await.unwrap();
    db.initialize().await.unwrap();
    let repo = SessionRepository::new(&db);

    assert!(repo.get_session("main").await.unwrap().is_none());
    repo.set_session("main", "sess-123").await.unwrap();
    assert_eq!(repo.get_session("main").await.unwrap(), Some("sess-123".to_string()));

    // Update
    repo.set_session("main", "sess-456").await.unwrap();
    assert_eq!(repo.get_session("main").await.unwrap(), Some("sess-456".to_string()));
}
```

**Step 4: 运行测试**

```bash
cargo test -p ngb-db -- sessions
```

**Step 5: 在 orchestrator.rs 中集成**

修改 `poll_messages()`:
- 从 `SessionRepository` 读取 group 的 session_id
- 传递给 `enqueue_message_check()`
- 容器返回 `newSessionId` 后写回 DB

**Step 6: Commit**

```bash
git add crates/ngb-db/ crates/ngb-core/src/orchestrator.rs
git commit -m "feat: add session ID persistence (Gap 5)"
```

---

## Task 5: 容器启动准备 (Gap 4)

**目标：** 容器启动前同步 skills、初始化 settings.json、写入 tasks/groups 快照

**Files:**
- Modify: `crates/ngb-core/src/container_runner.rs`
- Create: `crates/ngb-core/src/container_prep.rs`（新模块）
- Modify: `crates/ngb-core/src/lib.rs`（注册模块）

**Step 1: 创建 container_prep.rs**

```rust
/// Pre-launch preparation for agent containers.
///
/// Before spawning a container, the host must:
/// 1. Ensure group workspace directory exists
/// 2. Initialize .claude/settings.json (if first run)
/// 3. Sync shared skills from container/skills/ to group's .claude/skills/
/// 4. Write current_tasks.json snapshot to IPC directory
/// 5. Write available_groups.json snapshot to IPC directory
/// 6. Filter environment variables (only ANTHROPIC_API_KEY etc.)

pub fn ensure_group_dirs(config: &Config, group_folder: &str) -> Result<()> { ... }
pub fn init_settings_json(sessions_dir: &Path, group_folder: &str) -> Result<()> { ... }
pub fn sync_skills(skills_src: &Path, sessions_dir: &Path, group_folder: &str) -> Result<()> { ... }
pub fn write_tasks_snapshot(ipc_dir: &Path, group_folder: &str, is_main: bool, tasks: &[ScheduledTask]) -> Result<()> { ... }
pub fn write_groups_snapshot(ipc_dir: &Path, group_folder: &str, is_main: bool, groups: &[RegisteredGroup]) -> Result<()> { ... }
pub fn filter_env_vars(config: &Config) -> HashMap<String, String> { ... }

/// Run all preparation steps before container launch.
pub async fn prepare_container_launch(
    config: &Config, db: &Database,
    group_folder: &str, is_main: bool,
) -> Result<HashMap<String, String>> { ... }
```

**Step 2: 写测试（使用 tempdir）**

测试 settings.json 创建、skills 同步、快照写入。

**Step 3: 在 container_runner.rs 中调用**

在 `run_container_inner()` 开头调用 `prepare_container_launch()`。

**Step 4: 运行测试**

```bash
cargo test -p ngb-core -- container_prep
```

**Step 5: Commit**

```bash
git add crates/ngb-core/src/container_prep.rs crates/ngb-core/src/container_runner.rs crates/ngb-core/src/lib.rs
git commit -m "feat: add container launch preparation (Gap 4)"
```

---

## Task 6: Telegram Channel 适配器

**目标：** 实现 Telegram 适配器，实现 ChannelSender trait

**Files:**
- Modify: `crates/ngb-channels/Cargo.toml`（添加 teloxide 依赖）
- Create: `crates/ngb-channels/src/telegram.rs`
- Modify: `crates/ngb-channels/src/lib.rs`
- Modify: `Cargo.toml`（workspace 添加 teloxide）

**Step 1: 添加依赖**

workspace Cargo.toml:
```toml
teloxide = { version = "0.13", features = ["macros"] }
```

ngb-channels/Cargo.toml:
```toml
[dependencies]
ngb-types = { workspace = true }
ngb-core = { workspace = true }
ngb-db = { workspace = true }
ngb-config = { workspace = true }
tokio = { workspace = true }
tracing = { workspace = true }
teloxide = { workspace = true }
serde_json = { workspace = true }
```

**Step 2: 实现 TelegramChannel**

```rust
pub struct TelegramChannel {
    bot: teloxide::Bot,
    db: Arc<Database>,
}

impl TelegramChannel {
    pub fn new(token: &str, db: Arc<Database>) -> Self { ... }

    /// Start listening for messages (long polling).
    /// Stores incoming messages to DB, returns JoinHandle.
    pub async fn start(&self) -> tokio::task::JoinHandle<()> { ... }
}

impl ChannelSender for TelegramChannel {
    fn owns_jid(&self, jid: &str) -> bool {
        jid.starts_with("telegram:")
    }

    fn send_message(&self, jid: &str, text: &str)
        -> Pin<Box<dyn Future<Output = Result<()>> + Send + '_>>
    {
        // Extract chat_id from JID format "telegram:{chat_id}"
        // Use bot.send_message(ChatId(chat_id), text)
        ...
    }
}
```

**Step 3: 写测试（mock bot）**

测试 JID 匹配、消息格式化。

**Step 4: 运行测试**

```bash
cargo test -p ngb-channels
```

**Step 5: Commit**

```bash
git add Cargo.toml Cargo.lock crates/ngb-channels/
git commit -m "feat: add Telegram channel adapter with teloxide"
```

---

## Task 7: CLI serve 子命令

**目标：** 实现 `ngb serve` 命令，启动 Orchestrator + Telegram Channel

**Files:**
- Modify: `crates/ngb-cli/Cargo.toml`（添加 clap 等依赖）
- Modify: `crates/ngb-cli/src/main.rs`
- Modify: `Cargo.toml`（workspace 添加 clap）

**Step 1: 添加依赖**

workspace Cargo.toml:
```toml
clap = { version = "4", features = ["derive"] }
```

ngb-cli/Cargo.toml:
```toml
[dependencies]
ngb-types = { workspace = true }
ngb-config = { workspace = true }
ngb-core = { workspace = true }
ngb-db = { workspace = true }
ngb-channels = { workspace = true }
tokio = { workspace = true, features = ["full"] }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
clap = { workspace = true }
```

**Step 2: 实现 CLI**

```rust
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "ngb", about = "NanoGridBot - Agent Runtime")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Start the orchestrator and channel listeners
    Serve,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Serve => serve().await?,
    }
    Ok(())
}

async fn serve() -> anyhow::Result<()> {
    // 1. Init logging
    // 2. Load config
    // 3. Init database
    // 4. Create Telegram channel
    // 5. Create Orchestrator
    // 6. Start Orchestrator + message loop
    // 7. Wait for shutdown signal (Ctrl+C)
}
```

**Step 3: 运行编译测试**

```bash
cargo build -p ngb-cli
```

**Step 4: Commit**

```bash
git add Cargo.toml Cargo.lock crates/ngb-cli/
git commit -m "feat: add CLI with serve subcommand"
```

---

## Task 8: 集成测试 + 端到端验证

**目标：** 验证完整链路可工作

**Files:**
- Create: `tests/build-by-rust/test_integration.md`（验证计划）

**Step 1: 编译验证**

```bash
cargo build --workspace
cargo test --workspace
cargo clippy --workspace -- -D warnings
```

**Step 2: 构建 Docker 镜像**

```bash
cd container && ./build.sh
```

**Step 3: 端到端验证（用户手动执行）**

提供验证计划：
1. 配置 `.env` 文件（ANTHROPIC_API_KEY, TELEGRAM_BOT_TOKEN）
2. 创建 `groups/main/CLAUDE.md`
3. 运行 `cargo run -p ngb-cli -- serve`
4. 在 Telegram 中发送 `@Bot hello`
5. 验证收到回复

**Step 4: 最终 Commit**

```bash
git add -A
git commit -m "feat: implement MVP Phase 3 - Telegram + Docker + CLI serve"
```

---

## 验证标准

| 检查项 | 标准 |
|--------|------|
| `cargo build --workspace` | 全部编译通过 |
| `cargo test --workspace` | 所有测试通过（162 + 新增） |
| `cargo clippy -- -D warnings` | 零警告 |
| `docker build` | 镜像构建成功 |
| `ngb serve` | 启动不报错，连接 Telegram |
| 端到端 | Telegram 发消息 → 收到 Agent 回复 |

## P1 后续增强（MVP 后迭代）

| Gap | 内容 | 影响 |
|-----|------|------|
| Gap 1 | 流式输出解析 | 用户更快看到回复 |
| Gap 2 | Idle timeout + _close sentinel | 容器保活，减少启动开销 |
| Gap 3 | 消息管道到活跃容器 | 多轮对话不需新容器 |
